{
  "version": 3,
  "sources": ["src/client.ts"],
  "sourcesContent": ["/**\n * GoRouter WebSocket Client Library\n * A comprehensive WebSocket client library with authentication, reconnection, and message queuing\n * \n * @version 1.0.0\n * @author GoRouter Team\n * @license MIT\n */\n\n// Type definitions\nexport interface WebSocketClientOptions {\n    // Connection settings\n    autoReconnect?: boolean;\n    maxReconnectAttempts?: number;\n    reconnectDelay?: number;\n    maxReconnectDelay?: number;\n    reconnectDecay?: number;\n    \n    // Authentication\n    token?: string | null;\n    tokenRefreshCallback?: (() => Promise<string>) | null;\n    \n    // Heartbeat/keepalive\n    heartbeatInterval?: number;\n    heartbeatTimeout?: number;\n    \n    // Message handling\n    queueMessages?: boolean;\n    maxQueueSize?: number;\n    \n    // Debugging\n    debug?: boolean;\n    logLevel?: 'debug' | 'info' | 'warn' | 'error';\n}\n\nexport interface UserInfo {\n    userId: string;\n    username: string;\n    role: string;\n}\n\nexport interface ConnectionMetrics {\n    connectTime: number | null;\n    reconnectCount: number;\n    messagessent: number;\n    messagesReceived: number;\n    lastError: Error | null;\n    uptime: number;\n    latency: number | null;\n}\n\nexport interface WebSocketMessage {\n    type: string;\n    id?: string;\n    [key: string]: any;\n}\n\nexport interface PendingCommand {\n    resolve: (value: any) => void;\n    reject: (reason: any) => void;\n    timeout: number;\n    command: string;\n}\n\nexport type ConnectionState = \n    | 'disconnected'\n    | 'connecting' \n    | 'connected'\n    | 'reconnecting'\n    | 'authenticating'\n    | 'authenticated'\n    | 'closing'\n    | 'closed';\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\n// Constants\nexport const CONNECTION_STATES: Record<string, ConnectionState> = {\n    DISCONNECTED: 'disconnected',\n    CONNECTING: 'connecting',\n    CONNECTED: 'connected',\n    RECONNECTING: 'reconnecting',\n    AUTHENTICATING: 'authenticating',\n    AUTHENTICATED: 'authenticated',\n    CLOSING: 'closing',\n    CLOSED: 'closed'\n} as const;\n\nexport const MESSAGE_TYPES = {\n    // Authentication\n    AUTH: 'auth',\n    AUTH_SUCCESS: 'auth_success',\n    AUTH_ERROR: 'auth_error',\n    AUTH_REQUIRED: 'auth_required',\n    \n    // Chat & Communication\n    CHAT_MESSAGE: 'chat_message',\n    ADMIN_COMMAND: 'admin_command',\n    \n    // System messages\n    GET_USERS: 'get_users',\n    USERS_LIST: 'users_list',\n    USER_JOINED: 'user_joined',\n    USER_LEFT: 'user_left',\n    \n    // Control messages\n    PING: 'ping',\n    PONG: 'pong',\n    \n    // Notifications\n    ADMIN_ANNOUNCEMENT: 'admin_announcement',\n    WELCOME: 'welcome',\n    ERROR: 'error',\n    \n    // Custom message types\n    CUSTOM: 'custom'\n} as const;\n\nconst DEFAULT_OPTIONS: Required<WebSocketClientOptions> = {\n    // Connection settings\n    autoReconnect: true,\n    maxReconnectAttempts: 5,\n    reconnectDelay: 1000,\n    maxReconnectDelay: 30000,\n    reconnectDecay: 1.5,\n    \n    // Authentication\n    token: null,\n    tokenRefreshCallback: null,\n    \n    // Heartbeat/keepalive\n    heartbeatInterval: 30000,\n    heartbeatTimeout: 5000,\n    \n    // Message handling\n    queueMessages: true,\n    maxQueueSize: 100,\n    \n    // Debugging\n    debug: false,\n    logLevel: 'info'\n};\n\n/**\n * Simple EventEmitter implementation with proper typing\n */\nexport class EventEmitter<TEventMap extends Record<string, any> = Record<string, any>> {\n    private _events: Partial<Record<keyof TEventMap, Array<(...args: any[]) => void>>> = {};\n\n    on<K extends keyof TEventMap>(event: K, listener: (...args: TEventMap[K]) => void): this {\n        if (!this._events[event]) {\n            this._events[event] = [];\n        }\n        this._events[event]!.push(listener);\n        return this;\n    }\n\n    once<K extends keyof TEventMap>(event: K, listener: (...args: TEventMap[K]) => void): this {\n        const onceWrapper = (...args: TEventMap[K]) => {\n            this.off(event, onceWrapper);\n            listener(...args);\n        };\n        return this.on(event, onceWrapper);\n    }\n\n    off<K extends keyof TEventMap>(event: K, listener?: (...args: TEventMap[K]) => void): this {\n        if (!this._events[event]) return this;\n        \n        if (!listener) {\n            delete this._events[event];\n            return this;\n        }\n        \n        const listeners = this._events[event]!;\n        const index = listeners.indexOf(listener);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n        return this;\n    }\n\n    emit<K extends keyof TEventMap>(event: K, ...args: any[]): boolean {\n        if (!this._events[event]) return false;\n        \n        const listeners = this._events[event]!.slice();\n        listeners.forEach(listener => {\n            try {\n                listener(...args);\n            } catch (error) {\n                console.error(`Error in event listener for '${String(event)}':`, error);\n            }\n        });\n        return true;\n    }\n\n    listenerCount<K extends keyof TEventMap>(event: K): number {\n        return this._events[event] ? this._events[event]!.length : 0;\n    }\n}\n\n// Event map for WebSocketClient\nexport interface WebSocketClientEventMap {\n    connected: [{ url: string; reconnectCount: number }];\n    disconnected: [{ code: number; reason: string; wasAuthenticated: boolean }];\n    error: [Error];\n    stateChange: [{ oldState: ConnectionState; newState: ConnectionState }];\n    message: [WebSocketMessage];\n    auth_success: [any];\n    auth_failed: [Error];\n    reconnecting: [{ attempt: number; maxAttempts: number; delay: number }];\n    reconnectFailed: [{ attempts: number; lastError: Error | null }];\n    heartbeatTimeout: [];\n    [key: string]: any[];\n}\n\n/**\n * WebSocket Client with comprehensive features and full TypeScript support\n */\nexport class WebSocketClient extends EventEmitter<WebSocketClientEventMap> {\n    // Static properties for constants\n    static CONNECTION_STATES: typeof CONNECTION_STATES;\n    static MESSAGE_TYPES: typeof MESSAGE_TYPES;\n    static EventEmitter: typeof EventEmitter;\n    \n    public readonly url: string;\n    public readonly options: Required<WebSocketClientOptions>;\n    \n    // Connection state\n    public state: ConnectionState = CONNECTION_STATES.DISCONNECTED;\n    public ws: WebSocket | null = null;\n    public lastError: Error | null = null;\n    \n    // Authentication state\n    public authenticated: boolean = false;\n    public userInfo: UserInfo | null = null;\n    \n    // Reconnection state\n    public reconnectAttempts: number = 0;\n    private reconnectTimer: number | null = null;\n    private shouldReconnect: boolean = false;\n    \n    // Message handling\n    private messageQueue: WebSocketMessage[] = [];\n    private pendingCommands = new Map<string, PendingCommand>();\n    private commandId: number = 0;\n    \n    // Heartbeat\n    private heartbeatTimer: number | null = null;\n    private heartbeatTimeoutTimer: number | null = null;\n    private lastPongTime: number | null = null;\n    private heartbeatSentTime: number = 0;\n    \n    // Connection metrics\n    public metrics: Omit<ConnectionMetrics, 'uptime' | 'latency'> = {\n        connectTime: null,\n        reconnectCount: 0,\n        messagessent: 0,\n        messagesReceived: 0,\n        lastError: null\n    };\n\n    /**\n     * Create a WebSocket client\n     * @param url - WebSocket server URL\n     * @param options - Configuration options\n     */\n    constructor(url: string, options: WebSocketClientOptions = {}) {\n        super();\n        \n        this.url = url;\n        this.options = { ...DEFAULT_OPTIONS, ...options };\n        \n        // Bind methods to preserve `this` context\n        this._onOpen = this._onOpen.bind(this);\n        this._onClose = this._onClose.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onMessage = this._onMessage.bind(this);\n    }\n\n    /**\n     * Connect to the WebSocket server\n     */\n    async connect(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (this.state === CONNECTION_STATES.CONNECTING || this.state === CONNECTION_STATES.CONNECTED) {\n                resolve();\n                return;\n            }\n\n            this._log('debug', 'Initiating connection...');\n            this._setState(CONNECTION_STATES.CONNECTING);\n            this.shouldReconnect = true;\n\n            // Clear any existing connection\n            this._cleanup();\n\n            // Build WebSocket URL with token if provided\n            let wsUrl = this.url;\n            if (this.options.token) {\n                const separator = this.url.includes('?') ? '&' : '?';\n                wsUrl = `${this.url}${separator}token=${encodeURIComponent(this.options.token)}`;\n            }\n\n            try {\n                this.ws = new WebSocket(wsUrl);\n                this.ws.onopen = this._onOpen;\n                this.ws.onclose = this._onClose;\n                this.ws.onerror = this._onError;\n                this.ws.onmessage = this._onMessage;\n\n                // Set up connection timeout\n                const connectTimeout = setTimeout(() => {\n                    if (this.state === CONNECTION_STATES.CONNECTING) {\n                        this._log('error', 'Connection timeout');\n                        this.disconnect();\n                        reject(new Error('Connection timeout'));\n                    }\n                }, 10000);\n\n                // Wait for successful connection\n                this.once('connected', () => {\n                    clearTimeout(connectTimeout);\n                    resolve();\n                });\n\n                this.once('error', (error) => {\n                    clearTimeout(connectTimeout);\n                    reject(error);\n                });\n\n            } catch (error) {\n                this._log('error', 'Failed to create WebSocket connection:', error);\n                this._setState(CONNECTION_STATES.DISCONNECTED);\n                reject(error);\n            }\n        });\n    }\n\n    /**\n     * Disconnect from the WebSocket server\n     */\n    disconnect(): void {\n        this._log('debug', 'Disconnecting...');\n        this.shouldReconnect = false;\n        this._setState(CONNECTION_STATES.CLOSING);\n        \n        this._stopHeartbeat();\n        this._clearReconnectTimer();\n        \n        if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n            this.ws.close(1000, 'Client disconnect');\n        } else {\n            this._cleanup();\n            this._setState(CONNECTION_STATES.DISCONNECTED);\n        }\n    }\n\n    /**\n     * Reconnect to the WebSocket server\n     */\n    reconnect(): void {\n        this._log('debug', 'Manual reconnect requested');\n        this.reconnectAttempts = 0;\n        this.disconnect();\n        setTimeout(() => this.connect(), 100);\n    }\n\n    /**\n     * Send a message to the server\n     */\n    async send(message: WebSocketMessage): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.isConnected()) {\n                if (this.options.queueMessages) {\n                    this._queueMessage(message);\n                    this._log('debug', 'Message queued (not connected)', message);\n                    resolve();\n                } else {\n                    reject(new Error('Not connected'));\n                }\n                return;\n            }\n\n            try {\n                const messageStr = JSON.stringify(message);\n                this.ws!.send(messageStr);\n                this.metrics.messagessent++;\n                this._log('debug', 'Message sent:', message);\n                resolve();\n            } catch (error) {\n                this._log('error', 'Failed to send message:', error);\n                reject(error);\n            }\n        });\n    }\n\n    /**\n     * Send a command and wait for a response\n     */\n    async sendCommand(command: string, data: Record<string, any> = {}, timeout: number = 5000): Promise<any> {\n        return new Promise((resolve, reject) => {\n            const commandId = this._generateCommandId();\n            const message: WebSocketMessage = {\n                type: command,\n                id: commandId,\n                ...data\n            };\n\n            // Set up timeout\n            const timeoutTimer = setTimeout(() => {\n                this.pendingCommands.delete(commandId);\n                reject(new Error(`Command timeout: ${command}`));\n            }, timeout);\n\n            // Store command callback\n            this.pendingCommands.set(commandId, {\n                resolve,\n                reject,\n                timeout: timeoutTimer,\n                command\n            });\n\n            // Send command\n            this.send(message).catch(error => {\n                clearTimeout(timeoutTimer);\n                this.pendingCommands.delete(commandId);\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * Check if the client is connected\n     */\n    isConnected(): boolean {\n        return this.ws !== null && this.ws.readyState === WebSocket.OPEN;\n    }\n\n    /**\n     * Check if the client is authenticated\n     */\n    isAuthenticated(): boolean {\n        return this.authenticated && this.userInfo !== null;\n    }\n\n    /**\n     * Get current connection state\n     */\n    getConnectionState(): ConnectionState {\n        return this.state;\n    }\n\n    /**\n     * Get number of queued messages\n     */\n    getQueuedMessageCount(): number {\n        return this.messageQueue.length;\n    }\n\n    /**\n     * Get connection metrics\n     */\n    getMetrics(): ConnectionMetrics {\n        return {\n            ...this.metrics,\n            uptime: this.metrics.connectTime ? Date.now() - this.metrics.connectTime : 0,\n            latency: this.lastPongTime ? this.lastPongTime - this.heartbeatSentTime : null\n        };\n    }\n\n    /**\n     * Get user information\n     */\n    getUserInfo(): UserInfo | null {\n        return this.userInfo;\n    }\n\n    // Private methods\n\n    private _setState(newState: ConnectionState): void {\n        if (this.state !== newState) {\n            const oldState = this.state;\n            this.state = newState;\n            this._log('debug', `State changed: ${oldState} -> ${newState}`);\n            this.emit('stateChange', { oldState, newState });\n        }\n    }\n\n    private _onOpen(): void {\n        this._log('info', 'WebSocket connected');\n        this._setState(CONNECTION_STATES.CONNECTED);\n        this.metrics.connectTime = Date.now();\n        this.metrics.reconnectCount = this.reconnectAttempts;\n        this.reconnectAttempts = 0;\n        this.lastError = null;\n        \n        this._startHeartbeat();\n        this._processMessageQueue();\n        \n        this.emit('connected', {\n            url: this.url,\n            reconnectCount: this.metrics.reconnectCount\n        });\n    }\n\n    private _onClose(event: CloseEvent): void {\n        this._log('info', `WebSocket closed: ${event.code} ${event.reason}`);\n        this._cleanup();\n        this._setState(CONNECTION_STATES.DISCONNECTED);\n        this.authenticated = false;\n        this.userInfo = null;\n        \n        this.emit('disconnected', {\n            code: event.code,\n            reason: event.reason,\n            wasAuthenticated: this.authenticated\n        });\n\n        if (this.shouldReconnect && this.options.autoReconnect) {\n            this._scheduleReconnect();\n        }\n    }\n\n    private _onError(error: Event): void {\n        this._log('error', 'WebSocket error:', error);\n        const errorObj = new Error('WebSocket error');\n        this.lastError = errorObj;\n        this.metrics.lastError = errorObj;\n        this.emit('error', errorObj);\n    }\n\n    private _onMessage(event: MessageEvent): void {\n        this.metrics.messagesReceived++;\n        \n        try {\n            const data: WebSocketMessage = JSON.parse(event.data);\n            this._log('debug', 'Message received:', data);\n            this._handleMessage(data);\n        } catch (error) {\n            this._log('error', 'Failed to parse message:', error);\n            this.emit('error', new Error('Invalid message format'));\n        }\n    }\n\n    private _handleMessage(data: WebSocketMessage): void {\n        const { type, id } = data;\n\n        // Handle command responses\n        if (id && this.pendingCommands.has(id)) {\n            const command = this.pendingCommands.get(id)!;\n            clearTimeout(command.timeout);\n            this.pendingCommands.delete(id);\n            \n            if (type === MESSAGE_TYPES.ERROR) {\n                command.reject(new Error(data.message || 'Command failed'));\n            } else {\n                command.resolve(data);\n            }\n            return;\n        }\n\n        // Handle specific message types\n        switch (type) {\n            case MESSAGE_TYPES.AUTH_SUCCESS:\n                this._handleAuthSuccess(data);\n                break;\n                \n            case MESSAGE_TYPES.AUTH_ERROR:\n                this._handleAuthError(data);\n                break;\n                \n            case MESSAGE_TYPES.AUTH_REQUIRED:\n                this._handleAuthRequired(data);\n                break;\n                \n            case MESSAGE_TYPES.PONG:\n                this._handlePong();\n                break;\n                \n            case MESSAGE_TYPES.ERROR:\n                this.emit('error', new Error(data.message || 'Server error'));\n                break;\n                \n            default:\n                // Emit generic message event\n                this.emit('message', data);\n                \n                // Emit specific message type events\n                this.emit(type, data);\n                break;\n        }\n    }\n\n    private _handleAuthSuccess(data: any): void {\n        this._log('info', 'Authentication successful:', data);\n        this.authenticated = true;\n        this.userInfo = {\n            userId: data.user_id,\n            username: data.username,\n            role: data.role\n        };\n        this._setState(CONNECTION_STATES.AUTHENTICATED);\n        this.emit('auth_success', data);\n    }\n\n    private _handleAuthError(data: any): void {\n        this._log('error', 'Authentication failed:', data);\n        this.authenticated = false;\n        this.userInfo = null;\n        this.emit('auth_failed', new Error(data.message || 'Authentication failed'));\n    }\n\n    private _handleAuthRequired(data: any): void {\n        this._log('debug', 'Authentication required:', data);\n        this._setState(CONNECTION_STATES.AUTHENTICATING);\n        \n        if (this.options.token) {\n            // Send authentication message\n            this.send({\n                type: MESSAGE_TYPES.AUTH,\n                token: this.options.token\n            });\n        } else {\n            this.emit('auth_failed', new Error('No authentication token provided'));\n        }\n    }\n\n    private _handlePong(): void {\n        this.lastPongTime = Date.now();\n        this._log('debug', 'Pong received');\n        \n        if (this.heartbeatTimeoutTimer) {\n            clearTimeout(this.heartbeatTimeoutTimer);\n            this.heartbeatTimeoutTimer = null;\n        }\n    }\n\n    private _startHeartbeat(): void {\n        if (this.options.heartbeatInterval <= 0) return;\n        \n        this._stopHeartbeat();\n        \n        this.heartbeatTimer = setInterval(() => {\n            if (this.isConnected()) {\n                this.heartbeatSentTime = Date.now();\n                this.send({ type: MESSAGE_TYPES.PING });\n                \n                // Set timeout for pong response\n                this.heartbeatTimeoutTimer = setTimeout(() => {\n                    this._log('warn', 'Heartbeat timeout - connection may be dead');\n                    this.emit('heartbeatTimeout', []);\n                    \n                    if (this.options.autoReconnect) {\n                        this.reconnect();\n                    }\n                }, this.options.heartbeatTimeout);\n            }\n        }, this.options.heartbeatInterval);\n    }\n\n    private _stopHeartbeat(): void {\n        if (this.heartbeatTimer) {\n            clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = null;\n        }\n        \n        if (this.heartbeatTimeoutTimer) {\n            clearTimeout(this.heartbeatTimeoutTimer);\n            this.heartbeatTimeoutTimer = null;\n        }\n    }\n\n    private _queueMessage(message: WebSocketMessage): void {\n        if (this.messageQueue.length >= this.options.maxQueueSize) {\n            this.messageQueue.shift(); // Remove oldest message\n        }\n        this.messageQueue.push(message);\n    }\n\n    private _processMessageQueue(): void {\n        if (this.messageQueue.length === 0) return;\n        \n        this._log('debug', `Processing ${this.messageQueue.length} queued messages`);\n        \n        const queue = this.messageQueue.slice();\n        this.messageQueue = [];\n        \n        queue.forEach(message => {\n            this.send(message).catch(error => {\n                this._log('error', 'Failed to send queued message:', error);\n            });\n        });\n    }\n\n    private _scheduleReconnect(): void {\n        if (this.reconnectAttempts >= this.options.maxReconnectAttempts) {\n            this._log('error', 'Max reconnection attempts reached');\n            this.emit('reconnectFailed', {\n                attempts: this.reconnectAttempts,\n                lastError: this.lastError\n            });\n            return;\n        }\n\n        this.reconnectAttempts++;\n        const delay = Math.min(\n            this.options.reconnectDelay * Math.pow(this.options.reconnectDecay, this.reconnectAttempts - 1),\n            this.options.maxReconnectDelay\n        );\n\n        this._log('info', `Scheduling reconnect attempt ${this.reconnectAttempts}/${this.options.maxReconnectAttempts} in ${delay}ms`);\n        this._setState(CONNECTION_STATES.RECONNECTING);\n        \n        this.emit('reconnecting', {\n            attempt: this.reconnectAttempts,\n            maxAttempts: this.options.maxReconnectAttempts,\n            delay\n        });\n\n        this._clearReconnectTimer();\n        this.reconnectTimer = setTimeout(() => {\n            if (this.shouldReconnect) {\n                this.connect().catch(error => {\n                    this._log('error', 'Reconnection failed:', error);\n                    this._scheduleReconnect();\n                });\n            }\n        }, delay);\n    }\n\n    private _clearReconnectTimer(): void {\n        if (this.reconnectTimer) {\n            clearTimeout(this.reconnectTimer);\n            this.reconnectTimer = null;\n        }\n    }\n\n    private _cleanup(): void {\n        this._stopHeartbeat();\n        \n        if (this.ws) {\n            this.ws.onopen = null;\n            this.ws.onclose = null;\n            this.ws.onerror = null;\n            this.ws.onmessage = null;\n            this.ws = null;\n        }\n        \n        // Clear pending commands\n        this.pendingCommands.forEach(command => {\n            clearTimeout(command.timeout);\n            command.reject(new Error('Connection closed'));\n        });\n        this.pendingCommands.clear();\n    }\n\n    private _generateCommandId(): string {\n        return `cmd_${++this.commandId}_${Date.now()}`;\n    }\n\n    private _log(level: LogLevel, ...args: any[]): void {\n        if (!this.options.debug) return;\n        \n        const levels: Record<LogLevel, number> = { debug: 0, info: 1, warn: 2, error: 3 };\n        const currentLevel = levels[this.options.logLevel] || 1;\n        const messageLevel = levels[level] || 1;\n        \n        if (messageLevel >= currentLevel) {\n            console[level](`[WebSocketClient:${level.toUpperCase()}]`, ...args);\n        }\n    }\n}\n\n// Add static properties to the constructor\nWebSocketClient.CONNECTION_STATES = CONNECTION_STATES;\nWebSocketClient.MESSAGE_TYPES = MESSAGE_TYPES;\nWebSocketClient.EventEmitter = EventEmitter;\n\n// Export the constructor as default for IIFE format\nexport default WebSocketClient;"],
  "mappings": "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",
  "names": []
}
